# 内存管理


### 无存储器抽象存在的问题
1. 用户程序可以访问任意内存，容易破坏操作系统，造成崩溃
2. 同时运行多个程序特别困难

### 存储器抽象：地址空间
1.  **基址寄存器与界限寄存器**可以简单的动态重定位，每个内存地址送到内存之前，都会自动加上基址寄存器的内容。
2.  **交换技术**把一个进程完全调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存在磁盘上，所以当他们不运行时就不会占用内存。

### 空闲内存的管理
1. **使用位图的内存管理** 提供了一种简单的利用一块固定大小的内存区域能对内存使用情况进行记录的方法，但是问题在于当把一个占 k 个单元的进程调入内存时，存储管理器必须搜索位图，在位图中查找 k 个连续 0 的串>，这个查找过程是个耗时操作。
2. **使用链表的存储管理** 维护记录已分配内存段和空闲内存段的链表。为创建的进程分配内存时有以下算法
    *  首次适配算法
    *  下次适配算法
    *  最佳适配算法
    *  最差适配算法
    *  快速适配算法（为那些常用大小的空闲区维护单独的链表）
也可以为进程和空闲区维护各自的链表，这样能提高以上 4  个算法的速度，但是这样会增加复杂度，而且使内存释放速度变慢。
![](https://raw.githubusercontent.com/acmerfight/insight_python/master/images/system1.png)

### 虚拟内存

 1. 虚拟内存的基本思想是每个程序拥有自己的地址空间，这个空间可以被分割成多个块，每个块称为一页，每一页又连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。
 2. 在使用虚拟内存的情况下，虚拟地址会被送到内存管理单元 MMU，MMU 把虚拟地址映射为物理内存地址。
 3. 虚拟内存的本质是创造一个新的抽象概念---**地址空间**，这个概念对应的是物理内存的抽象。虚拟内存的实现是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者解除映射。
 4. 转换检测缓冲区（Translation Lookaside Buffer, TLB）又称为快表，提供中间由虚拟地址转换为物理地址时的缓存，可以直接将虚拟地址映射到物理地址，加速分页过程。
 5. 如何处理巨大的虚拟地址空间，
    * 多级页表，分级索引更多的地址空间
    * 倒排页表，使用页框号而不是虚拟页号来索引页表项，中间通过 TLB 加速

### 页面置换算法

 1. 最优页面置换算法，根据页面被访问前所需要的指令数作为标记，根据指令数的由多到少进行置换，这个方法对评价页面置换算法很有用，但它在实际系统中却不能使用，因为无法真正的实现。
 2. 最近未使用页面置换算法，NRU，在最近的一个时钟周期内，淘汰一个没有被访问的已修改页面，近似 LRU 算法，NRU 只是更粗略些。
 3. 先进先出的页面置换算法，FIFO，使用链表，可能抛弃重要页面。
 4. 第二次机会页面置换算法，比 FIFO 有重大改善。
 5. 时钟页面置换算法，现实。
 6. 最近最少使用页面置换算法，优秀但是难以实现。
 7. NFU（Not Frendly Used）最不常用算法。
